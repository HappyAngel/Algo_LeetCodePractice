/*
	problem:
	Given a sorted array of integers, find the starting and ending position of a given target value.
	Your algorithm's runtime complexity must be in the order of O(log n).
	If the target is not found in the array, return [-1, -1].
	For example,
	Given [5, 7, 7, 8, 8, 10] and target value 8,
	return [3, 4].

	ideas: transformed binary search.
*/
class Solution {
public:
    vector<int> searchRange(int A[], int n, int target) {

		vector<int> result;
		
		if(n==1 && A[0] == target)
		{
			result.push_back(0);
			result.push_back(0);
			return result;
		}
		
		int result1, result2;
        
		int lowIndex = 0;
        int highIndex = n-1;
        
        while (lowIndex < highIndex)
        {
            int middleIndex = (lowIndex + highIndex + 1) / 2;
            
            if(A[middleIndex] < target)
            {
                lowIndex = middleIndex;
            }
            else
            {
                highIndex = middleIndex-1;
            }
        }
        
		result1 = highIndex;

		if(A[highIndex] != target && A[highIndex+1] == target)
		{
			result1++;
		}

        lowIndex = 0;
        highIndex = n-1;
        
        while (lowIndex < highIndex)
        {
            int middleIndex = (lowIndex + highIndex) / 2;
            
            if(A[middleIndex] <= target)
            {
                lowIndex = middleIndex+1;
            }
            else
            {
                highIndex = middleIndex;
            }
        }

        result2 = lowIndex;
		
		if(A[lowIndex] != target && A[lowIndex-1] == target)
		{
			result2--;
		}

        if(result1 <= result2 && (A[result1]==target || A[result2]==target))
        {
            result.push_back(result1);
            result.push_back(result2); 
        }
        else
        {
            result.push_back(-1);
            result.push_back(-1);
        }

		return result;
    }
};
